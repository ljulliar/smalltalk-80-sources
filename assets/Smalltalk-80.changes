'From Smalltalk-80, version 2, of April 1, 1983 on 15 May 2020 at 11:05:34 am'!!PosixFilePage methodsFor: 'file/page/directory implementation'!pageNumber: pn	pageNumber _ pn! !!PosixFilePage methodsFor: 'accessing'!serialNumber: n 	^self!size: size	bytesInPage _ size! !!PosixFile methodsFor: 'private'!doCommand: command name: name page: page  error: e	| result |	result _ self doPrimCommand: command name: name page: page.	(result == false or: [ result isNil] ) ifTrue: [ 		e isNil ifFalse: [ error _ self errorString: self lastError.				self error: e]].	^result!doPrimCommand: command name: name page: page	<primitive: 130>!findLastPageNumber	|bytes|	"pages are numbered 1..N"	bytes _ self sizeOnDisk.	^ lastPageNumber _ ((bytes + self pageSize - 1) // self pageSize) max: 1! !!PosixFile methodsFor: 'file/page/directory implementation'!fd: descriptor	fd _ descriptor! !!PosixFile methodsFor: 'error handling'!errorString: anInteger	<primitive: 133>!lastError	<primitive: 132>! !!PosixFile methodsFor: 'file status'!close	fd isNil ifFalse: [ ^self doCommand: 5 name: nil page: nil error:nil ]!open	self doCommand: 4 name: fileName page: nil error: 'open:'.	readWrite _ Read.	self findLastPageNumber! !!PosixFile methodsFor: 'file accessing'!beSnapshotFile	<primitive: 128>!endFile: aPage	| nextPage |	"Make the file end with aFilePage, i.e., remove all file pages after 	aFilePage, and answer the result of writing aFilePage (File|write:). If the argument is	nil, delete all of the receiver's pages."		aPage isNil ifFalse: [ nextPage _ self write: aPage ]		    ifTrue: [ nextPage _ nil ].	"truncate"	self doCommand: 2 name: nil page: aPage error:'endFile:'.	self findLastPageNumber.	^nextPage! !!PosixFile methodsFor: 'nonhomogenous accessing'!read: page	"Read aFilePage if it exists, else answer false.  aFilePage contains a pageNumber and other	information, e.g., a serialNumber necessary to obtain the page.  It is possible that 	aFilePage pageNumber = 0 may or may not exist in some file systems. The pageNumber may	be used to compute a byte range to be read, or to lookup a disk address in a table.	In a file system where pages are linked, aFilePage may contain the address	of the next page and may help reveal lastPageNumber."	(self doCommand: 0 name: nil page: page error:'read:') ifFalse: [^nil].	^page!write: page	| returnPage |	self doCommand: 1 name: nil page: page error:'write:'.	returnPage _ page.	((page lastPage) and: [page isFull])	  ifTrue: ["last page can't be full, so glue on another page"		returnPage _ self initPageNumber: 0.		returnPage reinitialize.		returnPage pageNumber: (lastPageNumber _ page pageNumber + 1)].	readWrite _ Read + Write.	^returnPage! !!PosixFileDirectory methodsFor: 'private'!doPrimitive: code arg1: arg1 arg2: arg2	<primitive: 131>! !!PosixFileDirectory methodsFor: 'enumerating'!do: aBlock 	| files |	files _ (self fileNames collect: [ : aFileName | self initFileName: aFileName  ]).	(ReadStream on:files) do: aBlock! !!PosixFileDirectory methodsFor: 'removing'!removeOld: aFile	self doPrimitive: 1 arg1: aFile fileName arg2: nil! !!PosixFileDirectory methodsFor: 'adding'!add: aFile 	^self addNew: aFile!addNew: aFile 	| fd |	fd _ self doPrimitive: 0 arg1: aFile fileName arg2: nil.	aFile fd: fd.	aFile readWrite: Write.	^aFile! !!PosixFileDirectory methodsFor: 'file accessing'!rename: aFile newName: newFileName	self doPrimitive: 2 arg1: newFileName arg2: aFile! !Smalltalk condenseChanges!'----SNAPSHOT----'!'----SNAPSHOT----'!